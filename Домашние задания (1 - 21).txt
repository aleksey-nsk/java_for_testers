Задание 1. Подготовить инфраструктуру и создать первую работающую программу

Повторить действия, которые были продемонстрированы в лекциях:

  - Создать новый репозиторий на GitHub и клонировать его
    на локальную машину.
  - Сделать в локальной копии репозитория подкаталог sandbox.
  - Внутри этого подкаталога создать структуру поддиректорий и файлов,
    которая необходима для работы сборщика Gradle.
  - Создать первую простую программу, которая выводит 
    некоторый текст на экран.
  - Настроить конфигурационный файл сборщика, чтобы он мог запускать 
    эту программу.
  - Создать в среде разработки IDEA проект, который соответствует 
    репозиторию, а внутри проекта модуль, который соответствует
    подкаталогу sandbox (во втором занятии в этот проект будет добавлен
    ещё один модуль, а потом ещё и ещё).
  - Убедиться в том, что созданная программа успешно выполняется как 
    из консоли (при помощи сборщика), так и из среды разработки.
  - "Закоммитить" все сделанные изменения и синхронизировать 
    с удалённым репозиторием.

----------------------------------------------------

Задание 2. Потренироваться использовать функции, классы, объекты и методы

1. Создать класс Point для представления точек на двумерной плоскости.
Объекты этого класса должны содержать два атрибута, которые соответствуют
координатам точки на плоскости.

2. Создать функцию
public static double distance(Point p1, Point p2)
которая вычисляет расстояние между двумя точками. Для вычисления квадратного
корня можно использовать функцию Math.sqrt

3. Сделать запускаемый класс, то есть содержащий функцию
public static void main(String[] args) {...}
и при помощи него убедиться, что функция вычисления расстояния между точками 
действительно работает. Результат вычисления выводить на экран 
и контролировать визуально.

4. Реализовать то же самое (вычисление расстояния между двумя точками) 
при помощи метода в классе Point, и добавить в созданный 
в предыдущем пункте запускаемый класс примеры использования метода 
вместо ранее созданной функции.

----------------------------------------------------

Задание 3. Подключить тестовый фреймворк и сделать первые тесты

Подключить к модулю sandbox тестовый фреймворк TestNG и сделать несколько 
тестов для класса Point, которые проверяют, что расстояние между точками 
вычисляется правильно.

----------------------------------------------------

Задание 4. Сделать тесты для создания групп и контактов в адресной книге

Перед выполнением этого задания необходимо подготовить тестовый стенд 
и установить учебное приложение.

Повторить действия, которые были продемонстрированы в лекциях:

  - Создать новый модуль addressbook-web-tests в уже существующем проекте,
    аналогично тому, как ранее создавался модуль sandbox
  - Записать в Katalon Recorder тест для создания новой группы 
    в адресной книге
  - Перевести тест на язык Java и перенести его в среду разработки. 
    При экспорте использовать формат "Java (WebDriver + TestNG)"
  - Добавить в созданный модуль зависимость от библиотеки selenium-java
  - Убедиться, что проект успешно компилируется и тест успешно выполняется.
  - В этот момент можно уложить промежуточные результаты работы 
    в репозиторий.
  - Выделить из кода теста вспомогательные методы, 
    в том числе метод заполнения формы.
  - В этот момент можно опять уложить промежуточные результаты работы 
    в репозиторий.
  - Параметризовать метод заполнения формы.
  - Сгруппировать параметры метода заполнения формы в объект, сделать 
    вспомогательный "модельный" класс GroupData
    для представления таких объектов.
  - И снова можно уложить результаты работы в репозиторий. Делайте это 
    после каждого успешного шага. А если что-то сломалось -- можно отменить
    изменения, вернуться к предыдущему работающему состоянию,
    и попробовать ещё раз.

Затем сделать тест для создания нового Контакта, проделав аналогичную 
последовательностью действий.

----------------------------------------------------

Задание 5. Реализовать двухуровневую архитектуру тестового набора

Повторить действия, продемонстрированные в лекциях, выполняя 
одновременно трансформацию тестов и для групп, и для контактов:

  - Сделать общий базовый класс для тестов TestBase, перенести 
    вспомогательные методы в него (включая инициализацию и завершение).
  - Сделать класс ApplicationManager и перенести вспомогательные методы
    в него. Это рекомендуется делать при помощи рефакторинга в два шага,
    как описано в лекции "Заменяем наследование на делегирование".
  - Выделить из ApplicationManager специализированные классы-помощники
    ContactHelper, GroupHelper, NavigationHelper и SessionHelper. Перенести
    в них из ApplicationManager соответствующие вспомогательные методы.
  - Создать для этих вспомогательных классов общий базовый класс HelperBase,
    перенести в него низкоуровневые вспомогательные методы (заполнение
    отдельного поля, нажатие на кнопку или ссылку).

После каждого шага проверяйте, что проект компилируется и тесты работают.
Кроме того, после каждого успешного шага делайте commit в репозиторий. Если
что-то сломалось, не получилось сделать какой-то шаг -- отмените изменения,
вернитесь к предыдущему работающему состоянию и попробуйте ещё раз.

----------------------------------------------------

Задание 6. Сделать тесты для удаления и модификации групп и контактов

Реализовать все недостающие (не реализованные в предыдущих домашних
заданиях) тесты для создания, удаления и модификации групп и контактов,
создавая попутно вспомогательные методы, какие потребуются.

При этом вспомогательные методы сразу добавляйте 
в соответствующие классы-помощники.

Для создания вспомогательных методов можно использовать рекордер, но
сценарий целиком не нужно записывать, пишите сценарии вручную как 
последовательность обращений к вспомогательным методам.

Для закрытия диалогового окна (alert), которое появляется при удалении 
контакта, нужно использовать такую команду драйвера:
wd.switchTo().alert().accept();

После каждого шага проверяйте, что проект компилируется и тесты работают.
Кроме того, после каждого успешного шага делайте commit в репозиторий. Если
что-то сломалось, не получилось сделать какой-то шаг -- отмените изменения,
вернитесь к предыдущему работающему состоянию и попробуйте ещё раз.

----------------------------------------------------

Задание 7. Научиться запускать тесты в разных браузерах

Реализовать возможность запуска тестов в разных браузерах 
(как минимум в двух, например, Firefox и Chrome).

----------------------------------------------------

Задание 8. Реализовать проверку и обеспечение выполнения предусловий 
в тестах

Доработать тесты для удаления/модификации групп и контактов, чтобы они 
предварительно проверяли наличие хотя бы одного элемента, который можно 
удалить/модифицировать, и если такого элемента нет -- предварительно 
создавали его.

----------------------------------------------------

Задание 9. Реализовать проверки путём сравнения списков

Реализовать проверки путём сравнения списков в тестах для создания, 
удаления и модификации групп и контактов.

Для контактов пока достаточно учитывать в сравнении только имя и фамилию. 
О том, как сравнивать телефоны и адреса электронной почты -- в следующем 
занятии.

В тестах для создания и модификации нужно упорядочивать списки 
перед сравнением.

----------------------------------------------------

Задание 10. Реализовать проверки в fluent-стиле

Во всех тестах для создания/удаления/модификации групп и контактов 
реализовать проверки в fluent-стиле, используя библиотеку Hamcrest.

Для этого нужно предварительно сделать контейнер для хранения 
множества групп или контактов, который добавляет методы withAdded и without 
(в лекциях показано, как это сделать для групп), а потом использовать этот 
контейнер в тестах.

----------------------------------------------------

Задание 11. Реализовать тест для проверки информации о контактах 
на главной странице

Реализовать тест для проверки телефонов (продемонстрировано в лекциях), 
почтового адреса и адресов электронной почты 
на главной странице приложения.

Тест должен проверять только один какой-нибудь контакт, сравнивать 
информацию о контакте, которая представлена на главной странице, 
с информацией, представленной в форме редактирования контакта.

Рекомендуется использовать метод обратных проверок.

----------------------------------------------------

Задание 12. Реализовать генераторы тестовых данных

Реализовать генераторы тестовых данных для групп и для контактов, которые 
сохраняют данные в файл в формате XML или JSON (достаточно в каком-нибудь 
одном формате).

----------------------------------------------------

Задание 13. Параметризовать тесты для создания групп и контактов

Реализовать для тестов создания групп и контактов провайдеры 
тестовых данных, которые читают данные из файлов в формате XML или JSON 
(достаточно в каком-нибудь одном формате).

----------------------------------------------------

Задание 14. Вынести описание тестового стенда в конфигурационный файл

Реализовать загрузку информации о тестовом стенде из 
конфигурационного файла.

Цель -- избавиться от всех явных упоминаний в коде тестов адресов, имён,
паролей, и прочих строковых данных, которые могут меняться при изменении
конфигурации тестируемого приложения.

Реализовать возможность указания при запуске тестов того, какой 
конфигурационный файл должен использоваться, передавая эту информацию 
через системные свойства.

----------------------------------------------------

Задание 15. Реализовать проверку данных, загружаемых из БД

Во всех тестах для создания/удаления/модификации групп и контактов 
реализовать проверки списков, загружаемых из базы данных, а не из 
пользовательского интерфейса.

При этом можно сравнивать больше атрибутов, в том числе те, которые 
не показываются в веб-интерфейсе в списках групп и контактов. Но некоторые
атрибуты сравнивать достаточно сложно, например, фотографию контакта, 
поэтому такие сложные атрибуты можно пропустить,
не включать их в сравнение.

----------------------------------------------------

Задание 16. Реализовать тесты для добавления контакта в группу и удаления 
контакта из группы

Реализовать тесты для добавления контакта в группу 
и удаления контакта из группы.

Все действия выполнять через пользовательский интерфейс, а при проверках 
использовать информацию, загружаемую из базы данных напрямую.

Не забудьте также реализовать проверку и обеспечение предусловий.

----------------------------------------------------

Задание 17. Подготовить новый проект для нового учебного приложения

Подготовить новый проект для нового учебного приложения:
        
  1. Создать новый модуль в IDEA
  2. Добавить в него конфигурационный файл Gradle
     и всё необходимое для запуска сборщика
  3. Создать структуру директорий для хранения кода.
  4. Создать TestBase и ApplicationManager (перенести из существующего
     модуля и адаптировать, удалить весь неиспользуемый код).
         
----------------------------------------------------

Задание 18. Реализовать тест для смены пароля в MantisBT

Реализовать сценарий смены пароля пользователю баг-трекера MantisBT 
администратором системы:

  1. Администратор входит в систему, переходит на страницу управления 
     пользователями, выбирает заданного пользователя и нажимает
     кнопку Reset Password
  2. Отправляется письмо на адрес пользователя, тесты должны получить это
     письмо, извлечь из него ссылку для смены пароля, пройти по этой ссылке
     и изменить пароль.
  3. Затем тесты должны проверить, что пользователь может 
     войти в систему с новым паролем.
                
Изменить конфигурацию MantisBT можно вручную, не обязательно подменять
конфигурационный файл при запуске тестов. Пользователя тоже можно заранее
создать вручную.

Однако получить информацию об идентификаторе и/или логине пользователя
тесты должны самостоятельно во время выполнения. Можно это сделать, 
например, загрузив информацию о пользователях из базы данных.

Почтовый сервер можно запускать непосредственно внутри тестов.

Шаги 1 и 2 необходимо выполнять через пользовательский интерфейс,
а шаг 3 можно выполнить на уровне протокола HTTP.

----------------------------------------------------

Задание 19. Реализовать интеграцию тестов с баг-трекером MantisBT

Представьте себе, что баг-репорты для тестируемой системы хранятся в 
баг-трекере MantisBT. Некоторые автотесты невозможно выполнить из-за наличия
багов в тестируемой системе. До тех пор, пока баг не исправлен, тест 
выполнять нет смысла, он должен быть отключен. Но как только статус 
баг-репорта меняется -- тест должен автоматически активироваться. 
Необходимо реализовать такую интеграцию тестов с баг-трекером.

Для этого нужно сделать следующее:

1) В классе TestBase, от которого наследуются все тесты, необходимо 
реализовать функцию boolean isIssueOpen(int issueId) , которая должна через
Remote API получать из баг-трекера информацию о баг-репорте с заданным 
идентификатором, и возвращать значение false или true в зависимости от того,
помечен он как исправленный или нет.

2) Туда же в TestBase необходимо добавить такую функцию:

public void skipIfNotFixed(int issueId) {
  if (isIssueOpen(issueId)) {
    throw new SkipException("Ignored because of issue " + issueId);
  }
}

и вызывать её в начале нужного теста, чтобы он пропускался, 
если баг ещё не исправлен.
                    
----------------------------------------------------

Задание 20. Реализовать интеграцию тестов с баг-трекером Bugify

Представьте себе, что баг-репорты для тестируемой системы хранятся в
баг-трекере Bugify. Некоторые автотесты невозможно выполнить из-за наличия
багов в тестируемой системе. До тех пор, пока баг не исправлен, тест 
выполнять нет смысла, он должен быть отключен. Но как только статус 
баг-репорта меняется -- тест должен автоматически активироваться. 
Необходимо реализовать такую интеграцию тестов с баг-трекером.

Для этого нужно сделать следующее:

1) В классе TestBase, от которого наследуются все тесты, необходимо 
реализовать функцию boolean isIssueOpen(int issueId) , которая должна 
через Remote API получать из баг-трекера информацию о баг-репорте 
с заданным идентификатором, и возвращать значение false или true 
в зависимости от того, помечен он как исправленный или нет.

2) Туда же в TestBase необходимо добавить такую функцию:

public void skipIfNotFixed(int issueId) {
  if (isIssueOpen(issueId)) {
    throw new SkipException("Ignored because of issue " + issueId);
  }
}

и вызывать её в начале нужного теста, чтобы он пропускался, 
если баг ещё не исправлен.

Посмотреть список доступных функций/запросов 
можно здесь: https://bugify.com/api

А тесты нужно нацеливать на вот эту 
инсталляцию Bugify: http://bugify.stqa.ru/api
Для доступа использовать API Key 288f44776e7bec4bf44fdfeb1e646490
      
----------------------------------------------------

Задание 21. Организовать запуск тестов на сервере непрерывной интеграции

Организовать запуск тестов на сервере непрерывной интеграции:

  1. Загрузить и запустить Jenkins
  2. Установить в Jenkins плагины Gradle plugin и Git plugin
  3. Загрузить и запустить Selenium Server
  4. Настроить запуск тестов для адресной книги 
     на сервере непрерывной интеграции Jenkins, при этом браузер 
     должен запускаться удалённо через Selenium Server
        
----------------------------------------------------
